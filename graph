//////////////////////////////////////////////////////////////// DFS //////////////////////////////////////////////////////////////////////

//...................................print dfs..................................
vector<int> ar[100001];
int visited[100001];
void dfs(int node)
{
    visited[node]=1;
    cout<<node<<" " ;
    for(auto child : ar[node])
    {
        if(visited[child]==0)
        {
          dfs(child);
        }
    }
}

//.............................no of connected components.........................

int cc_count=0;
for(int i=1;i<=n;i++)
{
    if(visited[i]==0)
    dfs(i),cc_count++;
}
cout<<"no of connected components are "<<cc_count;

//...........................sssp using dfs....................................

vector<int> ar[10001];
int visited[10001];
int dist[10001];

void dfs(int node,int d)
{
    visited[node]=1;
    dist[node]=d;
    for(int child : ar[node])
    {
        if(visited[child] == 0)
        {
            dfs(child,dist[node]+1);
        }
    }
}
int main()
{
  dfs(1,0)
}

//.......................Bipartite graph Test.............................

vector<int> ar[10001];
int visited[10001];
int col[10001];
bool dfs(int v,int c)
{
    visited[v] = 1;
    col[v] = c;
    
    for(int child: ar[v])
    {
        if(vis[child] == 0)
        {
            if(dfs(child,c^1) == false)
            {
                return false;
            }
        }
        else
        {
            if(col[v] == col[child])
            return false;
        }
    }
    return true;
}

//.......................cycle detection in graph using DFS........................
(returns true if there is cycle otherwise returns false)
bool dfs(int node, int par)
{
    visited[node]=1;
    
    for(int child: ar[node])
    {
        if(visited[child] == 0)
        {
            if(dfs(child,node) == true)
            {
                return true;
            }
        }
        else
        {
            if(child != par)
            return true;
        }
    }
    return false;
}

//.........................In/Out time implementation..............................

int timer=1;
bool dfs(int v)
{
    visited[v]=1;
    In[v] = timer++;
    
    for(int child : ar[v])
    {
        if(visited[child] == 0)
        dfs(child);
    }
    Out[v] = timer++;
}

//.........................finding the diameter of Tree...............................

vector<int> ar[10001];
int visited[10001];

int maxD,maxNode;

void dfs(int node, int d)
{
    visited[node]=1;
    if(d>maxD) maxD=d, maxNode=node;
    for(int child: ar[node])
    if(visited[child] == 0)
    dfs(child, d+1);
}
int main()
{
    maxD = -1;
    dfs(1,0);
    REP(i,n) visited[i]=0;
    maxD = -1;
    dfs(maxNode, 0);
    cout<<MaxD<<endl;
}

//.............................calculating subtree size using DFS in O(N).......................

int visited[100001],subSize[100001];
int dfs(int node)
{
    visited[node] =1;
    int curr_size = 1;
    for(int child : ar[node])
    {
        if(visited[child] == 0)
        {
            curr_size + = dfs(child);
        }
    }
    subSize[node] = curr_size;
    return curr_size;
}


////////////////////////////////////////////////////////////////// BFS /////////////////////////////////////////////////////////////////////////////

//..............................min distance of each node from source node....................................
void bfs(int src)
{
    queue<int> q;
    q.push(src);
    visited[src]=1;
    dist[src]=0;
    while(q.size()>0)
    {
        int curr = q.front();
        q.pop();
        
        for(int child : ar[curr])
        {
            if(visited[child] == 0)
            {
                q.push(child);
                dist[child] = dist[curr] + 1;
                visited[child] = 1;
            }
        }
    }
}

//////////////////////////////////////////////////////////////////finding Bridges /////////////////////////////////////////////////////////////////////

vector<int> ar[10001];
int In[10001],low[10001],visited[10001];
int timer;

void dfs(int node,int par)
{
	visited[node]=1;
	In[node]=low[node]=timer;
	timer++;
	
	for(auto child : ar[node])
	{
		if(child==par)
		continue;
		if(visited[child]==1)
		{	// edge node-child is a back edge
			low[node]=min(low[node],In[child]);
		}
		else
		{	// edge node-child is a forward edge
			dfs(child,node);
	
			if(low[child]>In[node])
			cout<<node<<" - "<<child<<" is a bridge"<<endl;
			low[node] = min(low[node],low[child]);
		}
	}
}
int main()
{
	dfs(1,-1);
}

//////////////////////////////////////////////////////////Articulation points (cut vertex)/////////////////////////////////////////////////////////////

vector<vector<int>> adj; // adjacency list of graph

vector<bool> visited;
vector<int> tin, low;
int timer;

void dfs(int v, int p = -1) {
    visited[v] = true;
    tin[v] = low[v] = timer++;
    int children=0;
    for (int to : adj[v]) {
        if (to == p) continue;
        if (visited[to]) {
            low[v] = min(low[v], tin[to]);
        } else {
            dfs(to, v);
            low[v] = min(low[v], low[to]);
            if (low[to] >= tin[v] && p!=-1)
                IS_CUTPOINT(v);
            ++children;
        }
    }
    if(p == -1 && children > 1)
        IS_CUTPOINT(v);
}

////////////////////////////////////////////////////////////TOPOLOGICAL SORT/////////////////////////////////////////////////////////////////////////

............................Kahn's Algorithm (V+E)...............................

#include<bits/stdc++.h>
using namespace std;

vector<int> ar[100];
vector<int> res;
int in[100];

void kahn(int n)
{
	queue<int> q; // ( for sorted order use priority_queue)
	for(int i=1;i<=n;i++)
	if(in[i]==0)
	q.push(i);
	
	while(q.size()>0)
	{
		int curr = q.front();
		res.push_back(curr);
		q.pop();
		
		for(int node : ar[curr])
		{
			in[node]--;
			if(in[node]==0)
				q.push(node);
		}
	}
	cout<<"Topological Sort is : ";
	for(int node : res)
	cout<<node<<" ";
}
int main()
{
	int n,m,x,y;
	cin>>n>>m;
	for(int i=0;i<m;i++)
	{
		cin>>x>>y;
		ar[x].push_back(y);
		in[y]++;
	}
	kahn(n);
}

//////////////////////////////////////////////////////////Apply DFS on 2D grid///////////////////////////////////////////////////////////
.....................................
1. cell = node
2. sides = edges
3. sides + corner = edges
.....................................

int n,m;
int visited[10001];
bool isValid(int x, int y)
{
	if(x<1 || x>n || y<1 || y>M)
	return false;
	if(visited[x][y]== true)
	return false;
	
	return true;
}
void dfs(int x, int y)
{
	visited[x][y]=1;
	cout<<x<<" " <<y<<endl;
	if(isValid(x-1,y))
	dfs(x-1,y);
	
	if(isValid(x,y+1))
	dfs(x,y+1);
	
	if(isValid(x+1,y))
	dfs(x+1,y);
	
	if(isValid(x,y-1))
	dfs(x,y-1);
}
int main()
{
	cin>>n>>m;
	dfs(1,1);
}
....................................................
			OR
....................................................

int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
void dfs(int x,int y)
{
	visited[x][y]=1;
	cout<<x<<" " <<y<<endl;
	
	for(int i=0;i<4;i++)
	if(isValid(x+dx[i], y+dy[i]))
	dfs(x+dx[i],y+dy[i]);
}

