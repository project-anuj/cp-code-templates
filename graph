//////////////////////////////////////////////////////////////// DFS //////////////////////////////////////////////////////////////////////

//...................................print dfs..................................
vector<int> ar[100001];
int visited[100001];
void dfs(int node)
{
    visited[node]=1;
    cout<<node<<" " ;
    for(auto child : ar[node])
    {
        if(visited[child]==0)
        {
          dfs(child);
        }
    }
}

//.............................no of connected components.........................

int cc_count=0;
for(int i=1;i<=n;i++)
{
    if(visited[i]==0)
    dfs(i),cc_count++;
}
cout<<"no of connected components are "<<cc_count;

//...........................sssp using dfs....................................

vector<int> ar[10001];
int visited[10001];
int dist[10001];

void dfs(int node,int d)
{
    visited[node]=1;
    dist[node]=d;
    for(int child : ar[node])
    {
        if(visited[child] == 0)
        {
            dfs(child,dist[node]+1);
        }
    }
}
int main()
{
  dfs(1,0)
}

//.......................Bipartite graph Test.............................

vector<int> ar[10001];
int visited[10001];
int col[10001];
bool dfs(int v,int c)
{
    visited[v] = 1;
    col[v] = c;
    
    for(int child: ar[v])
    {
        if(vis[child] == 0)
        {
            if(dfs(child,c^1) == false)
            {
                return false;
            }
        }
        else
        {
            if(col[v] == col[child])
            return false;
        }
    }
    return true;
}

//.......................cycle detection in graph using DFS........................
(returns true if there is cycle otherwise returns false)
bool dfs(int node, int par)
{
    visited[node]=1;
    
    for(int child: ar[node])
    {
        if(visited[child] == 0)
        {
            if(dfs(child,node) == true)
            {
                return true;
            }
        }
        else
        {
            if(child != par)
            return true;
        }
    }
    return false;
}

//.........................In/Out time implementation..............................

int timer=1;
bool dfs(int v)
{
    visited[v]=1;
    In[v] = timer++;
    
    for(int child : ar[v])
    {
        if(visited[child] == 0)
        dfs(child);
    }
    Out[v] = timer++;
}

//.........................finding the diameter of Tree...............................

vector<int> ar[10001];
int visited[10001];

int maxD,maxNode;

void dfs(int node, int d)
{
    visited[node]=1;
    if(d>maxD) maxD=d, maxNode=node;
    for(int child: ar[node])
    if(visited[child] == 0)
    dfs(child, d+1);
}
int main()
{
    maxD = -1;
    dfs(1,0);
    REP(i,n) visited[i]=0;
    maxD = -1;
    dfs(maxNode, 0);
    cout<<MaxD<<endl;
}

//.............................calculating subtree size using DFS in O(N).......................

int visited[100001],subSize[100001];
int dfs(int node)
{
    visited[node] =1;
    int curr_size = 1;
    for(int child : ar[node])
    {
        if(visited[child] == 0)
        {
            curr_size + = dfs(child);
        }
    }
    subSize[node] = curr_size;
    return curr_size;
}


////////////////////////////////////////////////////////////////// BFS /////////////////////////////////////////////////////////////////////////////

//..............................min distance of each node from source node....................................
void bfs(int src)
{
    queue<int> q;
    q.push(src);
    visited[src]=1;
    dist[src]=0;
    while(q.size()>0)
    {
        int curr = q.front();
        q.pop();
        
        for(int child : ar[curr])
        {
            if(visited[child] == 0)
            {
                q.push(child);
                dist[child] = dist[curr] + 1;
                visited[child] = 1;
            }
        }
    }
}

//////////////////////////////////////////////////////////////////finding Bridges /////////////////////////////////////////////////////////////////////

vector<int> ar[10001];
int In[10001],low[10001],visited[10001];
int timer;

void dfs(int node,int par)
{
	visited[node]=1;
	In[node]=low[node]=timer;
	timer++;
	
	for(auto child : ar[node])
	{
		if(child==par)
		continue;
		if(visited[child]==1)
		{	// edge node-child is a back edge
			low[node]=min(low[node],In[child]);
		}
		else
		{	// edge node-child is a forward edge
			dfs(child,node);
	
			if(low[child]>In[node])
			cout<<node<<" - "<<child<<" is a bridge"<<endl;
			low[node] = min(low[node],low[child]);
		}
	}
}
int main()
{
	dfs(1,-1);
}

//////////////////////////////////////////////////////////Articulation points (cut vertex)/////////////////////////////////////////////////////////////

vector<vector<int>> adj; // adjacency list of graph

vector<bool> visited;
vector<int> tin, low;
int timer;

void dfs(int v, int p = -1) {
    visited[v] = true;
    tin[v] = low[v] = timer++;
    int children=0;
    for (int to : adj[v]) {
        if (to == p) continue;
        if (visited[to]) {
            low[v] = min(low[v], tin[to]);
        } else {
            dfs(to, v);
            low[v] = min(low[v], low[to]);
            if (low[to] >= tin[v] && p!=-1)
                IS_CUTPOINT(v);
            ++children;
        }
    }
    if(p == -1 && children > 1)
        IS_CUTPOINT(v);
}

////////////////////////////////////////////////////////////TOPOLOGICAL SORT/////////////////////////////////////////////////////////////////////////

