///////////////////////////////////Binary Left and Right Shift//////////////////////////////////////////
...................................Left Shift....................................
n = n << i  (n=n*(2^i))

...................................Right Shift....................................
n = n >> i  (n = n/(2^i))(integer division)

..........................Checking for ith Set Bit...............................

cin >> n >> i;
int f = 1;
f = f << i;
int res= n & f;
if(res==0)
    cout<<"false"<<endl;
else
    cout<<"true"<<endl;

.................................
                OR
.................................
if(n & (1 << i ))
    cout<<"true";
else
    cout<<"false";
............................ Counting No of Set Bits (also known as the Hamming weight)...............................

.................................
            log(n)
.................................

cin >> n;
int count = 0;
while(n > 0)
{
    if((n & 1) > 0) count++;
    n = n >> 1;
}
cout<< count <<endl;

...........................................................
        log(n) (little bit faster than above)
...........................................................

Observation.....
    8 - 1 = 7       16 - 1 = 15         28 - 1 =27
    0 1 0 0 0       1 0 0 0 0           1 1 1 0 0
    0 0 0 0 1       0 0 0 0 1           0 0 0 0 1
    .........       .........           .........
    0 0 1 1 1       0 1 1 1 1           1 1 0 1 1
    .........       .........           .........
    
    to find n-1 , change the right most set bit to 0 and rest remain same.
    let...
            n = 0 0 1 0 0 0 0 0
         & n-1= 0 0 0 1 1 1 1 1
               .................
                0 0 0 0 0 0 0 0
               .................
     
    int cnt = 0;
    while(n > 0)
    {
        cnt++;
        n = n & (n-1);
    }
    cout<< cnt <<endl;
    
/////////////////////////////////////////// Xor and it's properties /////////////////////////////////////////////////////

A XOR B = A^B
................
1. Identity Element
    0^A = A

2. A ^ A = 0

3. Ordering of XOOR doesn't matter
      2^3^1 = (2^3)^1
            = 2^(1^3)
            = 3^(1^2)
            
///////////////////////////////////////////////All Pair Sum XOR////////////////////////////////////////////////////////// 

Given an array with n elements, calculate following
(A1 + A1)^(A1 + A2)^(A1 + A3)^......^(A1 + An)^
(A2 + A1)^(A2 + A2)^(A2 + A3)^......^(A2 + An)^
(A3 + A1)^(A3 + A2)^(A3 + A3)^......^(A3 + An)^
.
.
(An + A1)^(An + A2)^(An + A3)^......^(An + An)

(Naive approach will take O(n^2))

Observation..............
    let.....
            4 3 9 1
                    
                    8  7  13  5
                    7  6  12  4
                    13 12 18 10
                    5  4  10  2
                    (XOR of 2*a[i] i.e. diagonal elements only ,in O(n))
     

//////////////////////////////////////////////////Total Sum of all Pairs XOR ///////////////////////////////////////////////////

Given an array with n elements, calculate following
    (A1 ^ A2)+(A1 ^ A3)+(A1 ^ A4)+........+(A1 ^ An)^+
              (A2 ^ A3)+(A2 ^ A4)+........+(A2 ^ An)^+
                                                    '
                                                    '
                                                    '
                                           (An-1 ^ An)
                                           
 ..............................Naive approach O(n^2).............................
    int res=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            res += ar[i]^ar[j];
        }
    }
 ................................................................................
 
 Observation........
        let...
           5        3       9
           0101     0011    1001
           
           5^3 = 0110
           5^9 = 1100
           3^9 = 1010
           Total Sum = 0*(2^0)+2*(2^1)+2*(2^2)+2*(2^3)=28
           
           Here , no. of set bits at ith bit only contribute to the sum
           No of pairs with ith bit set = (no of elements with ith bit 1)*(no of elements with ith bit 0)
           
           code.....(O(nlog(n))
                    
                    int ar[10001];
                    int n,res=0;
                    cin>>n;
                    for(int i=1;i<=n;i++)
                    cin>>ar[i];
                    
                    for(int i=0;i<31;i++)           //(Assume 32 bit integer)
                    {
                        int cnt0=0, cnt1=0;
                        
                        for(int j=1;j<=n;j++)
                        {
                            if(ar[j] & (1 << i))     //(ith bit set)
                            cnt1++;
                            else
                            cnt0++;
                        }
                        int p = cnt0 * cnt1;
                        res +=(1<<i)*p;
                    }
                    cout<<res<<endl;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
